// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

enum ChangeMode {
  absolute,
  relative,
  relativeStep,
  ;
}

enum Control {
  play,
  pause,
  playPause,
  stop,
  previous,
  next,
  ;
}

enum Mute {
  mute,
  unmute,
  ;
}

class NowPlaying {
  final List<String>? artistImageKeys;
  final String? imageKey;
  final int? length;
  final PlatformInt64? seekPosition;
  final OneLine oneLine;
  final TwoLine twoLine;
  final ThreeLine threeLine;

  const NowPlaying({
    this.artistImageKeys,
    this.imageKey,
    this.length,
    this.seekPosition,
    required this.oneLine,
    required this.twoLine,
    required this.threeLine,
  });

  @override
  int get hashCode =>
      artistImageKeys.hashCode ^
      imageKey.hashCode ^
      length.hashCode ^
      seekPosition.hashCode ^
      oneLine.hashCode ^
      twoLine.hashCode ^
      threeLine.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is NowPlaying &&
          runtimeType == other.runtimeType &&
          artistImageKeys == other.artistImageKeys &&
          imageKey == other.imageKey &&
          length == other.length &&
          seekPosition == other.seekPosition &&
          oneLine == other.oneLine &&
          twoLine == other.twoLine &&
          threeLine == other.threeLine;
}

class OneLine {
  final String line1;

  const OneLine({
    required this.line1,
  });

  @override
  int get hashCode => line1.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OneLine &&
          runtimeType == other.runtimeType &&
          line1 == other.line1;
}

class Output {
  final String outputId;
  final String zoneId;
  final List<String> canGroupWithOutputIds;
  final String displayName;
  final Volume? volume;
  final List<SourceControls>? sourceControls;

  const Output({
    required this.outputId,
    required this.zoneId,
    required this.canGroupWithOutputIds,
    required this.displayName,
    this.volume,
    this.sourceControls,
  });

  @override
  int get hashCode =>
      outputId.hashCode ^
      zoneId.hashCode ^
      canGroupWithOutputIds.hashCode ^
      displayName.hashCode ^
      volume.hashCode ^
      sourceControls.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Output &&
          runtimeType == other.runtimeType &&
          outputId == other.outputId &&
          zoneId == other.zoneId &&
          canGroupWithOutputIds == other.canGroupWithOutputIds &&
          displayName == other.displayName &&
          volume == other.volume &&
          sourceControls == other.sourceControls;
}

enum PlayState {
  playing,
  paused,
  loading,
  stopped,
  ;
}

class QueueItem {
  final String? imageKey;
  final int length;
  final int queueItemId;
  final OneLine oneLine;
  final TwoLine twoLine;
  final ThreeLine threeLine;

  const QueueItem({
    this.imageKey,
    required this.length,
    required this.queueItemId,
    required this.oneLine,
    required this.twoLine,
    required this.threeLine,
  });

  @override
  int get hashCode =>
      imageKey.hashCode ^
      length.hashCode ^
      queueItemId.hashCode ^
      oneLine.hashCode ^
      twoLine.hashCode ^
      threeLine.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is QueueItem &&
          runtimeType == other.runtimeType &&
          imageKey == other.imageKey &&
          length == other.length &&
          queueItemId == other.queueItemId &&
          oneLine == other.oneLine &&
          twoLine == other.twoLine &&
          threeLine == other.threeLine;
}

enum Repeat {
  off,
  all,
  one,
  ;
}

enum Scale {
  number,
  decibel,
  incremental,
  ;
}

class SourceControls {
  final String controlKey;
  final String displayName;
  final bool supportsStandby;
  final Status status;

  const SourceControls({
    required this.controlKey,
    required this.displayName,
    required this.supportsStandby,
    required this.status,
  });

  @override
  int get hashCode =>
      controlKey.hashCode ^
      displayName.hashCode ^
      supportsStandby.hashCode ^
      status.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SourceControls &&
          runtimeType == other.runtimeType &&
          controlKey == other.controlKey &&
          displayName == other.displayName &&
          supportsStandby == other.supportsStandby &&
          status == other.status;
}

enum Status {
  selected,
  deselected,
  standby,
  indeterminate,
  ;
}

class ThreeLine {
  final String line1;
  final String line2;
  final String line3;

  const ThreeLine({
    required this.line1,
    required this.line2,
    required this.line3,
  });

  @override
  int get hashCode => line1.hashCode ^ line2.hashCode ^ line3.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ThreeLine &&
          runtimeType == other.runtimeType &&
          line1 == other.line1 &&
          line2 == other.line2 &&
          line3 == other.line3;
}

class TwoLine {
  final String line1;
  final String line2;

  const TwoLine({
    required this.line1,
    required this.line2,
  });

  @override
  int get hashCode => line1.hashCode ^ line2.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TwoLine &&
          runtimeType == other.runtimeType &&
          line1 == other.line1 &&
          line2 == other.line2;
}

class Volume {
  final Scale scale;
  final double? min;
  final double? max;
  final double? value;
  final double? step;
  final bool? isMuted;
  final double hardLimitMin;
  final double hardLimitMax;
  final double softLimit;

  const Volume({
    required this.scale,
    this.min,
    this.max,
    this.value,
    this.step,
    this.isMuted,
    required this.hardLimitMin,
    required this.hardLimitMax,
    required this.softLimit,
  });

  @override
  int get hashCode =>
      scale.hashCode ^
      min.hashCode ^
      max.hashCode ^
      value.hashCode ^
      step.hashCode ^
      isMuted.hashCode ^
      hardLimitMin.hashCode ^
      hardLimitMax.hashCode ^
      softLimit.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Volume &&
          runtimeType == other.runtimeType &&
          scale == other.scale &&
          min == other.min &&
          max == other.max &&
          value == other.value &&
          step == other.step &&
          isMuted == other.isMuted &&
          hardLimitMin == other.hardLimitMin &&
          hardLimitMax == other.hardLimitMax &&
          softLimit == other.softLimit;
}

class Zone {
  final String zoneId;
  final String displayName;
  final List<Output> outputs;
  final PlayState state;
  final bool isNextAllowed;
  final bool isPreviousAllowed;
  final bool isPauseAllowed;
  final bool isPlayAllowed;
  final bool isSeekAllowed;
  final PlatformInt64 queueItemsRemaining;
  final PlatformInt64 queueTimeRemaining;
  final NowPlaying? nowPlaying;
  final ZoneSettings settings;

  const Zone({
    required this.zoneId,
    required this.displayName,
    required this.outputs,
    required this.state,
    required this.isNextAllowed,
    required this.isPreviousAllowed,
    required this.isPauseAllowed,
    required this.isPlayAllowed,
    required this.isSeekAllowed,
    required this.queueItemsRemaining,
    required this.queueTimeRemaining,
    this.nowPlaying,
    required this.settings,
  });

  @override
  int get hashCode =>
      zoneId.hashCode ^
      displayName.hashCode ^
      outputs.hashCode ^
      state.hashCode ^
      isNextAllowed.hashCode ^
      isPreviousAllowed.hashCode ^
      isPauseAllowed.hashCode ^
      isPlayAllowed.hashCode ^
      isSeekAllowed.hashCode ^
      queueItemsRemaining.hashCode ^
      queueTimeRemaining.hashCode ^
      nowPlaying.hashCode ^
      settings.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Zone &&
          runtimeType == other.runtimeType &&
          zoneId == other.zoneId &&
          displayName == other.displayName &&
          outputs == other.outputs &&
          state == other.state &&
          isNextAllowed == other.isNextAllowed &&
          isPreviousAllowed == other.isPreviousAllowed &&
          isPauseAllowed == other.isPauseAllowed &&
          isPlayAllowed == other.isPlayAllowed &&
          isSeekAllowed == other.isSeekAllowed &&
          queueItemsRemaining == other.queueItemsRemaining &&
          queueTimeRemaining == other.queueTimeRemaining &&
          nowPlaying == other.nowPlaying &&
          settings == other.settings;
}

class ZoneSeek {
  final String zoneId;
  final PlatformInt64 queueTimeRemaining;
  final PlatformInt64? seekPosition;

  const ZoneSeek({
    required this.zoneId,
    required this.queueTimeRemaining,
    this.seekPosition,
  });

  @override
  int get hashCode =>
      zoneId.hashCode ^ queueTimeRemaining.hashCode ^ seekPosition.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ZoneSeek &&
          runtimeType == other.runtimeType &&
          zoneId == other.zoneId &&
          queueTimeRemaining == other.queueTimeRemaining &&
          seekPosition == other.seekPosition;
}

class ZoneSettings {
  final Repeat repeat;
  final bool shuffle;
  final bool autoRadio;

  const ZoneSettings({
    required this.repeat,
    required this.shuffle,
    required this.autoRadio,
  });

  @override
  int get hashCode => repeat.hashCode ^ shuffle.hashCode ^ autoRadio.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ZoneSettings &&
          runtimeType == other.runtimeType &&
          repeat == other.repeat &&
          shuffle == other.shuffle &&
          autoRadio == other.autoRadio;
}
